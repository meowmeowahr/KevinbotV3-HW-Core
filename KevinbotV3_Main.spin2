'' =================================================================================================
''
''   File....... KevinbotV3_Main.spin2
''   Purpose....
''   Author..... Kevin Ahr
''               Copyright (c) 2023 - 2024 Kevin Ahr
''   License.... MIT License
''   Started.... 03 SEP 2023
''
''   {$P2}
''
'' =================================================================================================


con { timing }

  CLK_FREQ = 200_000_000                                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                                               ' ticks in 1us

  _clkfreq = CLK_FREQ                                                           ' set system clock


con { terminal }

  #0, T_PST, T_ANSI                                                             ' terminal types

  T_TYPE = T_ANSI


con { fixed io pins }

  PGM_RX1  = 63  { I }                                                          ' programming / debug
  PGM_TX1  = 62  { O }

  SF_CS    = 61  { O }                                                          ' serial flash
  SF_SCK   = 60  { O }
  SF_SDO   = 59  { O }
  SF_SDI   = 58  { I }

  SD_SCK   = 61  { O }                                                          ' sd card
  SD_CS    = 60  { O }
  SD_SDO   = 59  { O }
  SD_SDI   = 58  { I }

  LED2     = 57  { O }                                                          ' Eval and Edge LEDs
  LED1     = 56  { O }

con

  #true,  ON, OFF
  #false, NO, YES

  #0, S_OK, S_UNKNOWN, S_OW_SHORT, S_OW_ERROR, S_OW_DNF, S_LCD_INIT_FAIL, S_TICK_FAIL, ...
      S_QUEUE_OVERRUN, S_ESTOP, S_BATT1_UV, S_BATT1_OV, S_BATT2_UV, S_BATT2_OV, S_BATT_UV, S_BATT_OV

  #0, L_LINKED, L_NO_LINK, L_LINK_WAIT
  #0, I_OFF, I_LINK, I_CHECK, I_ERROR
  #0, DP_SPLASH, DP_COM, DP_ERROR, DP_HOME, DP_WAIT


dat { Serial Queue }

' user set variables at task init
pRxByteStart            long    0
nRxByteMax              long    0

' TASK use variables

pRxByteHead             long    0                                               ' QUEUE control vars - received BYTEs
nRxByteCount            long    0

bInString               long    FALSE
pNewStrStart            long    0

pRsltStrStart           long    0

bQueOverrun             long    FALSE
bStrQueOverrun          long    FALSE

nQStrHeadIdx            long    0                                               ' QUEUE control vars - received strings
nQStrTailIdx            long    0
nQStrCount              long    0
rxStrPtrSet             long    0[sett.RX_BUFF_LONGS]                           ' circular buffer - ptrs to received strings

serialRxBffr            byte    0[sett.RX_BUFF_BYTES]                           ' circular buffer - received chars

' task vars
nTaskChr                long    0
' tsk vars

            '   pValues -> [0:nbrValues(1-n)]  (doesn't count "full string")    ENT_VALUE_CT_IDX
            '              [1:pStr] -> "full string"                            ENT_RAWSTR_IDX
            '              [2:pCmd] -> "cmd"                                    ENT_CMDSTR_IDX
            '              [3:eCmd]                                             ENT_CMDENUM_IDX
            '              [4:nValue1]                                          ENT_PARM1_IDX
            '              [5:nValue2]                                          ENT_PARM2_IDX
            '              [6:nValue3]                                          ENT_PARM3_IDX
            '              [7:nValue4]                                          ENT_PARM4_IDX
            '              [etc] - up to 6 max values


dat

Version                 byte    "v3.0.0-beta", 0                                ' Core version

DisplayUnlinkLine0      byte    "Tick Error"            , 0
DisplayUnlinkLine1      byte    "Tick not Recvd"        , 0

DisplayWaitingLine0     byte    "Please Wait..."        , 0
DisplayWaitingLine1     byte    "Waiting for System"    , 0

DisplayHomeEnaLine0     byte    "ROBOT ENABLED"         , 0
DisplayHomeDisLine0     byte    "ROBOT DISABLED"        , 0

DisplayErrorLine0       byte    "System Error"          , 0
DisplayErrorLine1       byte    "Error:"                , 0

DisplayEstopLine0       byte    " EMERGENCY STOP "      , 0
DisplayEstopLine1       byte    "Stop Requested"        , 0

' command table
Commands
                        byte    "core.pinh"             , 0                     ' Simple IO
                        byte    "core.pinl"             , 0
                        byte    "core.pint"             , 0
                        byte    "core.pinf"             , 0
                        byte    "core.tone"             , 0
                        byte    "system.tick"           , 0
                        byte    "core.errors.clear"     , 0
                        byte    "core.link.unlink"      , 0
                        byte    "connection.isready"    , 0
                        byte    "connection.ok"         , 0
                        byte    "system.enabled"        , 0
                        byte    "system.estop"          , 0
                        byte    0

NumCmds                 byte    12


rxDataBuffer            byte    0[sett.RX_MAX_LINE]                             ' Buffers for serial rx
rxCmdBuffer             byte    0[sett.RX_MAX_CMD]
rxValueBuffer           byte    0[sett.RX_MAX_VAL]

rxSubVal0Buffer         byte    0[sett.RX_MAX_SUBVAL]
rxSubVal1Buffer         byte    0[sett.RX_MAX_SUBVAL]
rxSubVal2Buffer         byte    0[sett.RX_MAX_SUBVAL]
rxSubVal3Buffer         byte    0[sett.RX_MAX_SUBVAL]

obj

' main                                                                          ' * master Spin cog

  pins  : "KevinbotV3_Pinmap"                                                   '   Kevinbot v3 Board Pinouts
  sett  : "KevinbotV3_Settings"                                                 '   Kevinbot v3 Static Settings

  batt  : "KevinbotV3_BatteryMgmt"                                              '   Kevinbot v3 Voltmeters and Battery Management
  temp  : "KevinbotV3_Thermometers"                                             '   Kevinbot v3 DS18b20 thermometers

  util  : "ka_utils"                                                            '   Misc utility methods
  str   : "string"                                                              '   String utilities

  beep  : "jm_pwm"                                                              '   error buzzer pwm
  rsl   : "KevinbotV3_StatusLight"                                              '   status light
  disp  : "KevinbotV3_StatusDisplay"                                            '   status lcd

  tk_tm : "jm_ez_timer"                                                         '   Core tick timer
  bt_tm : "jm_ez_timer"                                                         '   BMS update timer
  ds_tm : "jm_ez_timer"                                                         '   DS18b20 update timer
  dp_tm : "jm_ez_timer"                                                         '   Display update timer

  term  : "jm_fullduplexserial"                                                 ' * serial IO for terminal
  sys   : "jm_fullduplexserial"                                                 ' * serial IO for Kevinbot System
  ansi  : "jm_ansi"                                                             '   ANSI terminal control sequences

' * uses cog when loaded


var { globals }

  '' States
  byte core_status
  byte link_status
  byte robot_enabled
  byte handshake_requested

  '' Cogs
  byte sensor_cog_id
  long sensor_stack[128]

  byte rx_cog_id
  long taskStack[128]

  '' Tick
  long  last_core_tick
  long  last_system_tick

  '' Driver Init
  byte  term_cog_id
  byte  sys_serial_cog_id
  byte  lcd_init_status

  '' Batteries
  long  batt_1_voltage
  long  batt_2_voltage
  long  batt_meter_1_voltage
  long  batt_meter_2_voltage
  byte  batt_1_status
  byte  batt_2_status

  '' Temperatures
  long left_motor_temp
  long right_motor_temp
  long internal_temp

  '' Buzzer
  long buzzer_start_time
  long buzzer_end_time

  '' LCD
  long lcd_icon_update_time
  byte lcd_icon
  byte lcd_page

  byte lcd_previous_icon
  byte lcd_previous_page


pub main() | b1, b2, index, lcd_previous_enabled, lcd_error_string

  core_status := S_OK
  link_status := L_NO_LINK
  lcd_icon := I_LINK
  lcd_page := DP_WAIT
  lcd_previous_enabled := false
  robot_enabled := false
  handshake_requested := false

  setup()

  waitms(sett.STARTUP_DELAY)

  if sett.WAIT_FOR_TERM
    wait_for_terminal(false)

  if lcd_init_status == 0
    ' lcd init failed
    core_status := S_LCD_INIT_FAIL

  ' Cogs
  sensor_cog_id := cogspin(newcog, sensor_loop, @sensor_stack)
  rx_cog_id := cogspin(newcog, serial_queue_loop(@serialRxBffr, sett.RX_BUFF_BYTES), @taskStack)

  ' Start timers
  tk_tm.start()
  bt_tm.start()

  repeat
    ' Tick
    if tk_tm.millis() >= sett.TICK_SPEED
      sys.fstr1(string("core.uptime=%d", 10), getsec())
      sys.fstr1(string("core.uptime_ms=%d", 10), getms())

      ifnot core_status == S_OK
        sys.fstr1(string("core.error=%d", 10), core_status)

      tk_tm.start()

    ' Update battery data
    if bt_tm.millis() >= sett.BATT_SPEED
      batt_1_voltage, batt_2_voltage := batt.get_voltages()
      batt_meter_1_voltage, batt_meter_2_voltage := batt.get_raw_voltages()
      batt_1_status, batt_2_status := batt.get_statuses()

      sys.fstr2(string("bms.voltages=%d,%d", 10), batt_1_voltage, batt_2_voltage)
      sys.fstr2(string("bms.raw_voltages=%d,%d", 10), batt_meter_1_voltage, batt_meter_2_voltage)
      sys.fstr2(string("bms.status=%d,%d", 10), batt_1_status, batt_2_status)

      if sett.BATT_ERRORS
        if (batt_1_status == batt.S_UNDER) and (batt_2_status == batt.S_UNDER)
          ' both batts are dead
          core_status := S_BATT_UV
        elseif (batt_1_status == batt.S_OVER) and (batt_2_status == batt.S_OVER)
          ' both batts are over-volt
          core_status := S_BATT_OV
        elseif batt_1_status == batt.S_UNDER
          ' batt 1 is dead
          core_status := S_BATT1_UV
        elseif batt_1_status == batt.S_OVER
          ' batt 1 is over-volt
          core_status := S_BATT1_OV
        elseif batt_2_status == batt.S_UNDER
          ' batt 2 is dead
          core_status := S_BATT2_UV
        elseif batt_2_status == batt.S_OVER
          ' batt 2 is over-volt
          core_status := S_BATT2_OV

      bt_tm.start()

    ' Update rsl
    if sett.ENABLE_RSL
      if robot_enabled == 0
        rsl.set_state(1)
      elseif robot_enabled == 1
        rsl.set_state(2)
      else
        rsl.set_state(0)

      rsl.update()

    if serial_queue_has_data()
      get_serial_queue_data(@rxDataBuffer, sett.RX_MAX_LINE, true)              ' get and remove data from queue
      util.split_str2(@rxDataBuffer, "=", @rxCmdBuffer, @rxValueBuffer)         ' get message from serial
      term.str(@rxCmdBuffer)
      term.tx(13)
      term.tx(10)
      index := cmd_index(@rxCmdBuffer, @Commands, NumCmds)                      ' get command index
      case index
        1: pinh(str.atoi(@rxValueBuffer))                                       ' core.pinh
        2: pinl(str.atoi(@rxValueBuffer))                                       ' core.pinl
        3: pint(str.atoi(@rxValueBuffer))                                       ' core.pint
        4: pinf(str.atoi(@rxValueBuffer))                                       ' core.pinf
        5:                                                                      ' core.tone
          util.split_str3(@rxValueBuffer, ",", @rxSubVal0Buffer, @rxSubVal1Buffer, @rxSubVal2Buffer)
          buzzer_start_time := getms()
          buzzer_end_time := buzzer_start_time + str.atoi(@rxSubVal2Buffer)
          tone(str.atoi(@rxSubVal0Buffer), str.atoi(@rxSubVal1Buffer))
        6:                                                                      ' system.tick
          last_system_tick := getms()
          ' Check if re-handshake required
          if (not (link_status == L_LINKED)) and (handshake_requested == false)
            sys.str(string("connection.requesthandshake", 10))
            handshake_requested := true
        7:                                                                      ' core.errors.clear
          core_status := S_OK
          last_system_tick := getms()                                           ' prevent system tick error
          reset_serial_queue_status()
        8:                                                                      ' core.link.unlink
          if core_status == S_TICK_FAIL
            core_status := S_OK
          link_status := L_NO_LINK
        9:                                                                      ' connection.isready
          link_status := L_LINK_WAIT
          last_system_tick := getms()                                           ' prevent system tick error
          sys.str(string("ready", 10))
          ' handshake_requested := false
        10:                                                                     ' connection.ok
          link_status := L_LINKED
          last_system_tick := getms()                                           ' prevent system tick error
        11:                                                                     ' system.enabled
          if core_status == S_OK
            robot_enabled := str.atoi(@rxValueBuffer)
          else
            robot_enabled := 0
        12:                                                                     ' system.estop
          robot_enabled := 2
          core_status := S_ESTOP
          emergency_stop()


    else
      '' Non-critical tasks
      if buzzer_end_time < getms()
        beep.write(0)

      '' LCD Updates / Tick

      if sett.ENABLE_LCD
        if link_status == L_LINK_WAIT
          lcd_page := DP_WAIT
        elseif core_status == S_TICK_FAIL
          lcd_page := DP_COM
        elseifnot core_status == S_OK
          lcd_page := DP_ERROR
        elseif link_status == L_NO_LINK
          lcd_page := DP_WAIT
        else
          lcd_page := DP_HOME

      ' if error, set lcd icon
      case core_status
        S_OK:
          lcd_icon := I_CHECK
        other:
          lcd_icon := I_ERROR

      ' system tick errors / display
      if link_status == L_LINKED
        if (last_system_tick < getms() - sett.SYSTEM_TICK - sett.SYS_TICK_TOL)
          link_status := L_NO_LINK
          core_status := S_TICK_FAIL

      ' lcd loop every sett.DISP_SPEED ms
      if sett.ENABLE_LCD
        if dp_tm.millis() >= sett.DISP_SPEED
          if (not lcd_icon == lcd_previous_icon) or (not lcd_page == lcd_previous_page) or (not lcd_previous_enabled == robot_enabled)
            lcd_previous_enabled := robot_enabled
            disp.clear()

            ' LCD pages
            if lcd_page == DP_COM
              disp.display_main_lines(@DisplayUnlinkLine0, @DisplayUnlinkLine1)
            elseif lcd_page == DP_WAIT
              disp.display_main_lines(@DisplayWaitingLine0, @DisplayWaitingLine1)
            elseif lcd_page == DP_HOME
              if robot_enabled
                disp.display_main_lines(@DisplayHomeEnaLine0, "")
              else
                disp.display_main_lines(@DisplayHomeDisLine0, "")
            elseif lcd_page == DP_ERROR
              bytefill(@lcd_error_string, 0, strsize(@lcd_error_string))
              str.append(@lcd_error_string, @DisplayErrorLine1)
              str.append(@lcd_error_string, str.dec(core_status))
              disp.display_main_lines(@DisplayErrorLine0, @lcd_error_string)
            dp_tm.start()
            lcd_previous_icon := lcd_icon
            lcd_previous_page := lcd_page

        ' set lcd icons, animate outside of loop
        case lcd_icon
          I_OFF:
            if lcd_icon_update_time < getms() - sett.LCD_ICON_SPD
              lcd_icon_update_time := getms()
              disp.display_status_icon(disp.CC_NONE)

          I_LINK:
            if lcd_icon_update_time < getms() - sett.LCD_ICON_SPD
              lcd_icon_update_time := getms()
              if disp.get_lcd_icon() == disp.CC_REFRESH_1
                disp.display_status_icon(disp.CC_REFRESH_2)
              else
                disp.display_status_icon(disp.CC_REFRESH_1)

          I_CHECK:
            if lcd_icon_update_time < getms() - sett.LCD_ICON_SPD
              lcd_icon_update_time := getms()
              disp.display_status_icon(disp.CC_CHECK)

          I_ERROR:
            if lcd_icon_update_time < getms() - sett.LCD_ICON_SPD
              lcd_icon_update_time := getms()
              disp.display_status_icon(disp.CC_ERROR)


pub emergency_stop()
  cogstop(rx_cog_id)
  cogstop(sensor_cog_id)
  cogstop(term_cog_id)
  cogstop(sys_serial_cog_id)
  ' TODO: Motor kill here
  if sett.ENABLE_RSL
    rsl.set_state(0)
  if sett.ENABLE_LCD
    disp.display_status_icon(disp.CC_ERROR)
    disp.display_main_lines(@DisplayEstopLine0, @DisplayEstopLine1)
    disp.set_backlight(false)

  repeat
    waitct(0)


pub sensor_loop() | left, right, internal, owx_status

'' Sensor update cog

  ' DS18b20
  owx_status := temp.start(sett.get_left_motor_sn(), sett.get_right_motor_sn(), sett.get_internal_temp_sn(), pins.ONE_WIRE, temp.PU_1K5)

  if sett.OWX_ERRORS
    case owx_status
      temp.BUS_SHORT:
        core_status := S_OW_SHORT
        return
      temp.BAD_RESET:
        core_status := S_OW_ERROR
        return
      temp.NO_DEVICE:
        core_status := S_OW_DNF
        return

  ds_tm.start()

  repeat
    if ds_tm.millis() > sett.TEMP_SPEED
      left, right, internal := temp.read_temps()
      sys.txflush()
      sys.fstr3(string("sensors.temps=%d,%d,%d", 10), (left+50)/100, (right+50)/100, (internal+50)/100)
      ds_tm.start()


pub cmd_index(p_src, p_list, nc) : idx | byte buf[32], x, c

'' Convert command string into value
'' -- not case sensitive
'' -- returns 1..n if found in command table
'' -- returns 0 (false) if not found

  bytemove(@buf, p_src, strsize(p_src)+1)                       ' copy string + terminator

  x := 0
  repeat
    c := buf[x]
    if (c == 0)                                                 ' end of string
      quit
    elseif ((c >= "A") && (c <= "Z"))                           ' if uppercase
      buf[x] += 32                                              '  make lowercase
    x++

  repeat nc
    if (strcomp(@buf, p_list))
      return idx+1
    else
      idx += 1                                                  ' update index
      p_list += strsize(p_list) + 1                             ' update list pointer

  return 0


pub tone(amp, freq)

  beep.start(pins.BUZZER_PIN, amp, freq, beep.M_TRI)

'' ============================== ''
'' Serial Queue by Stephen Moraco ''
'' Debug Features Removed         ''
'' Licence: MIT License           ''
'' ============================== ''

pub serial_queue_has_data() : bPresentStatus
'' Return T/F where T means a control value change has been received and needs to be handled
    bPresentStatus := (nQStrCount > 0) ? TRUE : FALSE


pub serial_queue_count() : nCount
'' Return count of strings received
    nCount := nQStrCount


pub get_serial_queue_data(pUserDest, lenDest, bShouldWait) : pStr | bStringArrived, pWrappedStr, nLen
'' Return {pStr} or 0 if none
''  if {bShouldWait} is TRUE wait until string arrives before returning
    pStr := 0
    if bShouldWait == TRUE
        bStringArrived := TRUE
        repeat until serial_queue_has_data() == TRUE
    else
        bStringArrived := serial_queue_has_data()

    if bStringArrived == TRUE
        pStr := pUserDest
        pWrappedStr := serial_dequeue_str()
        bytefill(pUserDest, 0, lenDest)
        copy_wrapped_str(pUserDest, pWrappedStr, lenDest)
        nLen := strsize(pUserDest)
        free_wrapped_str(pWrappedStr, nLen)


pub flush_serial_queue()
'' Reset all Rx Queue control and data (emptying it!)
    bytefill(@serialRxBffr, 0, sett.RX_BUFF_BYTES)
    longfill(@rxStrPtrSet, 0, sett.RX_BUFF_LONGS)
    pRxByteHead := pRxByteStart

    bInString := FALSE

    nQStrHeadIdx := 0
    nQStrTailIdx := 0

    nRxByteCount := 0
    nQStrCount := 0

    pRsltStrStart := 0


pub reset_serial_queue_status()
'' Reset all task failure indicators
    bQueOverrun := FALSE
    bStrQueOverrun := FALSE


pri serial_queue_loop(pRxBffr, lenRxBffr)
' our serial receive to queue loop
    ' preserve incoming values
    pRxByteStart := pRxBffr
    nRxByteMax := lenRxBffr

    ' NOTE parameters are for DEBUG use only
    flush_serial_queue()


    ' read serial input forever placing chars in RX Circ Queue
    repeat
        nTaskChr := sys.rxtime(1000)
        if (nTaskChr <> -1)
            serial_enqueue_char(nTaskChr)


pri serial_enqueue_char(nChr) : bFailedStatus
' place byte into rx queue, if EOL then place term instead and engueue string ptr!
    bFailedStatus := FALSE
    if (nRxByteCount < nRxByteMax)
        if bInString == FALSE
            bInString := TRUE
            pNewStrStart := pRxByteHead
        nRxByteCount++
        if (nChr <> $0a)
            ' if NOT LF then save it
            byte [pRxByteHead++] := nChr
        else
            ' have LF terminate line
            byte [pRxByteHead++] := $00 ' place term instead of EOL
            if bInString == TRUE
                bInString := FALSE
                serial_enqueue_str(pNewStrStart)
        ' wrap ptr if needed...
        if pRxByteHead > @BYTE [@serialRxBffr][sett.RX_BUFF_BYTES - 1]
            pRxByteHead := @serialRxBffr
    else
        bQueOverrun := TRUE ' signal that we lost incoming data!!!
        core_status := S_QUEUE_OVERRUN
        bFailedStatus := TRUE


pri serial_enqueue_str(pStr) | strIdx
' report string arrival to listener (place string pointer in queue)
    if nQStrCount < sett.RX_BUFF_LONGS
        strIdx := nQStrHeadIdx  ' save for debug
        LONG [@rxStrPtrSet][nQStrHeadIdx++] := pStr
        ' if head goes off end-of-set then wrap
        if nQStrHeadIdx > sett.RX_BUFF_LONGS - 1
            nQStrHeadIdx := 0
        ' mark arrival of new in queue
        nQStrCount++
    else
        bStrQueOverrun := TRUE ' signal that we lost incoming data!!!


pri serial_dequeue_str() : pRmStr
' remove string from queue, listener done with it
    'dumpStrQ(string("B4 String Ptr Que"))
    if nQStrCount > 0
        pRmStr := LONG[@rxStrPtrSet][nQStrTailIdx++]
        if nQStrTailIdx > sett.RX_BUFF_LONGS - 1
            nQStrTailIdx := 0
        nQStrCount--
    'dumpStrQ(string("FTER String Ptr Que"))


pri serial_dequeue_result_str() : pRsltStr
' remove string from queue, listener done with it
    'dumpStrQ(string("B4 String Ptr Que"))
    pRsltStr := 0
    if pRsltStrStart <> 0
        pRsltStr := pRsltStrStart
        pRsltStrStart := 0  ' mark as empty


pri free_wrapped_str(pRmStr, nLen)
    ' zero our string memory
    zero_wrapped_str(pRmStr, nLen)


pri zero_wrapped_str(pRmStr, nLen) | nIdx, pSrc
' fill space occuppied by string with zero's
'  NOTE handle buffer wrap!
'    string can start near and and wrap to front!
    pSrc := pRmStr
    repeat nIdx from 0 to nLen - 1
        ' if pointing beyond end, wrap to front!
        if pSrc > @BYTE[@serialRxBffr][sett.RX_BUFF_BYTES-1]
          pSrc -= sett.RX_BUFF_BYTES
        BYTE[pSrc++] := 0
    nRxByteCount -= nLen + 1


pri copy_wrapped_str(pUserDest, pSrcStr, lenDest) | nIdx, pSrc, pDest
' copy possible wrapped string {pSrcStr} to {pUserDest} (use min(strlen,lenDest) as bytes to move)
'  NOTE handle buffer wrap!
'    string can start near and and wrap to front!
    pDest := pUserDest
    pSrc:= pSrcStr
    repeat nIdx from 0 to lenDest - 1
        ' if pointing beyond end, wrap to front!
        if pSrc > @BYTE[@serialRxBffr][sett.RX_BUFF_BYTES-1]
          pSrc -= sett.RX_BUFF_BYTES
        if BYTE[pSrc] == 0
            quit    ' at string end, quit loop
        BYTE[pDest++] := BYTE[pSrc++]
    BYTE[pDest] := 0  ' place final terminator


'' =================== ''
'' End of Serial Queue ''
'' =================== ''

pub setup()

'' Configure IO and objects for application

  ' Serial
  term_cog_id := term.tstart(sett.BR_TERM)                                         ' start terminal io
  sys_serial_cog_id := sys.start(pins.RPI_RX, pins.RPI_TX, %0000, sett.BR_SYSTEM)  ' start serial for system

  ' Voltmeter
  batt.start(sett.BMS_MODE, pins.VOLT1_P, pins.VOLT2_P, sett.B1_HIGH_VOLT, sett.B1_LOW_VOLT, sett.B2_HIGH_VOLT, sett.B2_LOW_VOLT)

  ' Display
  if sett.ENABLE_LCD
    lcd_init_status := disp.start(sett.LCD_ADDR, pins.SCL, pins.SDA, 100, disp.PU_1K5)
  else
    lcd_init_status := 1

  ' Status light
  if sett.ENABLE_RSL
    rsl.start(pins.RSL, sett.RSL_RATE)


pub wait_for_terminal(clear)

'' Wait for terminal to be open and key pressed

  term.rxflush()
  term.rx()
  if (clear)
    clear_screen()


pub clear_screen()

'' Move cursor home (upper left) and clear the terminal

  if (T_TYPE == T_PST)
    term.tx(term.HOME)
    term.tx(term.CLS)
  else
    term.str(ansi.hide_cursor())
    term.str(ansi.home())
    term.str(ansi.cls())
